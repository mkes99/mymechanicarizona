---
const {
  apiPath = "/api/reviews",
  max = 50,
  limit = 24,          // total cards to render in the slider (we will trim to a full "page")
  autoplay = true,
  autoplayMs = 5500,
  writeReviewUrl = "https://search.google.com/local/writereview?placeid=ChIJIRIHWwp01oYRVv-SOeBXy5o",
  title = "What customers are saying",
} = Astro.props;
---

<section
  class="reviews-slider"
  data-reviews-slider
  data-api={apiPath}
  data-max={max}
  data-limit={limit}
  data-autoplay={autoplay ? "1" : "0"}
  data-autoplay-ms={autoplayMs}
>
  <div class="reviews-slider__header">
    <h2 class="reviews-slider__title">{title}</h2>

    <a class="btn border-btn btn-wide" href={writeReviewUrl} target="_blank" rel="noopener">
      <span>Write a review</span>
    </a>
  </div>

  <div class="reviews-slider__status" data-status style="display:none;"></div>

  <div class="reviews-slider__frame" data-frame>
    <button
      type="button"
      class="reviews-slider__arrow reviews-slider__arrow--prev"
      data-prev
      aria-label="Previous reviews"
    >
      ‹
    </button>

    <div class="reviews-slider__viewport" data-viewport>
      <div class="reviews-slider__track" data-track></div>
    </div>

    <button
      type="button"
      class="reviews-slider__arrow reviews-slider__arrow--next"
      data-next
      aria-label="Next reviews"
    >
      ›
    </button>
  </div>
</section>

<script is:inline>
(() => {
  const root = document.querySelector('[data-reviews-slider]');
  if (!root) return;

  const api = root.getAttribute('data-api') || '/api/reviews';
  const max = Number(root.getAttribute('data-max') || '50');
  const limit = Number(root.getAttribute('data-limit') || '24');

  const autoplay = (root.getAttribute('data-autoplay') || '0') === '1';
  const autoplayMs = Number(root.getAttribute('data-autoplay-ms') || '5500') || 5500;

  const status = root.querySelector('[data-status]');
  const frame = root.querySelector('[data-frame]');
  const viewport = root.querySelector('[data-viewport]');
  const track = root.querySelector('[data-track]');
  const prevBtn = root.querySelector('[data-prev]');
  const nextBtn = root.querySelector('[data-next]');

  let baseItems = [];
  let renderItems = [];       // head clones + base + tail clones
  let perView = 4;
  let gapPx = 18;
  let cardW = 0;
  let stepPx = 0;

  // "index" is in CARD UNITS (not pages): we jump by perView cards at a time.
  // We start at index = perView so we're on the first real page (after the head clones).
  let index = 0;

  let timer = null;
  let isHover = false;
  let isAnimating = false;

  function setStatus(type, msg) {
    if (!status) return;
    status.style.display = 'block';
    status.className = `reviews-slider__status reviews-slider__status--${type}`;
    status.textContent = msg;
  }
  function hideStatus() {
    if (!status) return;
    status.style.display = 'none';
    status.textContent = '';
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#039;");
  }

  function renderStars(n) {
    const s = Math.max(0, Math.min(5, Number(n) || 0));
    return '★★★★★☆☆☆☆☆'.slice(5 - s, 10 - s);
  }

  function getGoogleUrl(r) {
    return (
      r.url ||
      r.review_url ||
      r.google_url ||
      r.link ||
      'https://www.google.com/maps?cid=11154105522663391062'
    );
  }

  function cardEl(r) {
    const name = r.reviewer_name || r.author_name || r.name || 'Anonymous';
    const text = r.review_text || r.text || r.content || '';
    const rating = Number(r.rating || r.stars || 0);

    const when =
      r.relative_time_description ||
      r.relative_time ||
      r.timeago ||
      r.time_ago ||
      '';

    const googleUrl = getGoogleUrl(r);

    const div = document.createElement('div');
    div.className = 'review-card review-card--slider';

    div.innerHTML = `
      <div class="review-card__meta">
        <div class="review-card__name">${escapeHtml(name)}</div>
        ${when ? `<div class="review-card__time">${escapeHtml(when)}</div>` : ``}
        <div class="review-card__stars">${escapeHtml(renderStars(rating))}</div>
      </div>

      <div class="review-card__text review-card__text--scroll">
        ${escapeHtml(text)}
      </div>

      <div class="review-card__footer">
        <a class="review-card__google" href="${escapeHtml(googleUrl)}" target="_blank" rel="noopener">
          View on Google
        </a>
      </div>
    `;
    return div;
  }

  function readGapPx() {
    if (!track) return 18;
    const style = window.getComputedStyle(track);
    const g = parseFloat(style.gap || style.columnGap || '0') || 0;
    return g;
  }

  // Measure how many cards fit (instead of window-width guessing)
  function measurePerView() {
    if (!viewport || !track) return 4;
    const kids = track.children;
    if (!kids || !kids.length) return 4;

    const first = kids[0].getBoundingClientRect();
    const vw = viewport.getBoundingClientRect().width;
    const gap = readGapPx();
    const w = first.width || 0;

    // how many "w + gap" segments fit into viewport (+gap to compensate rounding)
    let per = Math.floor((vw + gap) / (w + gap));
    per = Math.max(1, Math.min(4, per));
    return per;
  }

  function measureStep() {
    if (!track) return;
    const kids = track.children;
    if (!kids || !kids.length) return;

    gapPx = readGapPx();
    cardW = kids[0].getBoundingClientRect().width || 0;
    perView = measurePerView();

    // Step in PX for one FULL PAGE (perView cards)
    stepPx = (cardW * perView) + (gapPx * Math.max(0, perView));
    // Why +gapPx*perView? because between pages there is ALSO a gap after the last card when translating by card units.
    // We translate by card units (index) below, so we'll also compute cardStepPx:
  }

  function cardUnitPx() {
    // one card + one gap (the distance from card i to card i+1 in flex with gap)
    return (cardW + gapPx);
  }

  function setTranslate(px, animate) {
    if (!track) return;
    track.style.transition = animate ? 'transform 350ms ease' : 'none';
    track.style.transform = `translate3d(${-px}px, 0, 0)`;
  }

  function rebuildRenderItems() {
    // Ensure we only render full pages so we never show partial pages at the end
    // (infinite loop needs full pages to look clean).
    const fullPagesCount = Math.max(1, Math.floor(baseItems.length / perView));
    const usableCount = Math.max(perView, fullPagesCount * perView);
    const usable = baseItems.slice(0, usableCount);

    // clone perView at head/tail for seamless wrap
    const head = usable.slice(-perView);
    const tail = usable.slice(0, perView);

    renderItems = [...head, ...usable, ...tail];

    // start index at first real page (after head clones)
    index = perView;
  }

  function renderTrack() {
    if (!track) return;
    track.innerHTML = '';
    renderItems.forEach((r) => track.appendChild(cardEl(r)));
  }

  function snapToIndex(newIndex, animate) {
    if (!track) return;

    index = newIndex;

    // translate by card units (index cards from start)
    const px = cardUnitPx() * index;
    setTranslate(px, animate);
  }

  function go(dir) {
    if (isAnimating) return;
    if (!track) return;

    isAnimating = true;

    // move by one PAGE (perView cards)
    snapToIndex(index + (dir * perView), true);
  }

  function onTransitionEnd() {
    if (!track) return;

    // usable base length is renderItems - 2*perView
    const usableLen = renderItems.length - (2 * perView);

    // If we moved into tail clones, jump back to the equivalent real index
    // (no animation so it looks infinite).
    if (index >= usableLen + perView) {
      // wrap to first real page
      index = perView;
      snapToIndex(index, false);
    }

    // If we moved into head clones, jump to last real page
    if (index < perView) {
      index = usableLen;
      snapToIndex(index, false);
    }

    isAnimating = false;
  }

  function stopAuto() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }

  function startAuto() {
    stopAuto();
    if (!autoplay) return;

    timer = setInterval(() => {
      if (isHover) return;
      go(1);
    }, autoplayMs);
  }

  function bindHoverPause() {
    if (!frame) return;
    frame.addEventListener('mouseenter', () => { isHover = true; });
    frame.addEventListener('mouseleave', () => { isHover = false; });
  }

  function bindButtons() {
    if (prevBtn) prevBtn.addEventListener('click', () => { stopAuto(); go(-1); startAuto(); });
    if (nextBtn) nextBtn.addEventListener('click', () => { stopAuto(); go(1); startAuto(); });
  }

  function hardRecalcAndSnap() {
    // Called on resize: re-measure perView, rebuild clones, re-render, snap to start.
    if (!track || !viewport) return;

    // We need at least one card rendered to measure, so:
    // 1) render a temporary "base only" to measure.
    track.innerHTML = '';
    baseItems.slice(0, Math.min(baseItems.length, 8)).forEach((r) => track.appendChild(cardEl(r)));

    // 2) measure real perView using actual DOM
    measureStep();

    // 3) rebuild full render array using that perView
    rebuildRenderItems();

    // 4) render and snap to start (no animation)
    renderTrack();
    measureStep(); // re-measure now that real cards exist
    snapToIndex(perView, false);

    // force a second frame to avoid rounding jitter
    requestAnimationFrame(() => {
      measureStep();
      snapToIndex(perView, false);
    });
  }

  async function init() {
    if (!track || !viewport) return;

    try {
      const res = await fetch(api, { headers: { 'Accept': 'application/json' } });
      const data = await res.json().catch(() => null);

      const reviews = data && Array.isArray(data.reviews) ? data.reviews : [];
      baseItems = reviews.slice(0, Math.min(max, limit));

      if (!baseItems.length) {
        setStatus('empty', 'No reviews to display yet.');
        return;
      }

      hideStatus();

      // Initial render/recalc
      hardRecalcAndSnap();

      // Bind UI
      bindButtons();
      bindHoverPause();

      // Infinite wrap fix
      track.addEventListener('transitionend', onTransitionEnd);

      // Resize: rebuild + snap (prevents clipped partial cards)
      let resizeTimer = null;
      window.addEventListener('resize', () => {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          stopAuto();
          hardRecalcAndSnap();
          startAuto();
        }, 120);
      });

      // Start auto
      startAuto();
    } catch (e) {
      setStatus('error', 'Reviews are temporarily unavailable.');
    }
  }

  init();
})();
</script>